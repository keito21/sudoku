<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sudoku — Fresh Single File - By Keitozy </title>
  <style>
    :root{--bg:#0b1220;--card:#071328;--accent:#ef4444;--muted:#94a3b8;--cell:#0f1724;--good:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef8}
    .wrap{max-width:900px;margin:18px auto;padding:14px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:18px;margin:0;animation:glow 2s ease-in-out infinite alternate}
    @keyframes glow{0%{text-shadow:0 0 4px #ef4444;}100%{text-shadow:0 0 14px #ff6666;}}
    .controls{display:flex;gap:8px;align-items:center}
    button,select{background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
    .board{display:flex;gap:14px;margin-top:14px}
    .grid{display:grid;grid-template-columns:repeat(9,44px);grid-auto-rows:44px;background:var(--card);padding:10px;border-radius:10px;border:3px solid rgba(255,255,255,0.06)}
    .cell{border:1px solid rgba(255,255,255,0.06);width:44px;height:44px;border-radius:6px;display:flex;align-items:center;justify-content:center;background:var(--cell);position:relative}
    .cell input{width:100%;height:100%;text-align:center;border-radius:6px;border:0;background:transparent;color:inherit;font-size:18px}
    .cell.editable{background:rgba(239,68,68,0.12)}
    .cell.fixed{background:transparent;color:#cbd5e1}
    .cell.wrong{animation:shake 0.25s;background:rgba(255,0,0,0.35)!important}
    @keyframes shake{0%{transform:translateX(0);}25%{transform:translateX(-3px);}50%{transform:translateX(3px);}75%{transform:translateX(-3px);}100%{transform:translateX(0);}}
    .thick-col{border-right:4px solid var(--accent)}
    .thick-row{border-bottom:4px solid var(--accent)}
    #numpad button{padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.03);color:#fff}
    .sidebar{width:300px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:8px}
    textarea{width:100%;height:120px;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    .status{margin-top:8px;color:var(--muted);font-size:13px}
    .note-grid{position:absolute;inset:6px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:1px;font-size:9px;color:rgba(255,255,255,0.7);}
    .note-grid div{display:flex;align-items:center;justify-content:center;height:12px}
    .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    .small{font-size:13px;color:var(--muted)}
    @media(max-width:600px){
      .grid{grid-template-columns:repeat(9,30px);grid-auto-rows:30px;padding:6px}
      .cell{width:30px;height:30px}
      .sidebar{width:100%}
      #numpad button{padding:6px}
    }
  
/* FULL MOBILE RESPONSIVE FIX */
@media(max-width: 768px) {

  .wrap {
    padding: 10px;
  }

  header {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }

  .controls {
    flex-wrap: wrap;
    width: 100%;
  }

  .board {
    flex-direction: column;
    gap: 20px;
  }

  /* Grid auto-scale */
  .grid {
    width: 100%;
    max-width: 100%;
    grid-template-columns: repeat(9, 1fr);
    grid-auto-rows: calc((100vw - 40px) / 9);
  }

  .cell {
    width: 100%;
    height: 100%;
  }

  .cell input {
    font-size: 16px;
  }

  #numpad {
    justify-content: center;
  }

  #numpad button {
    flex: 1 0 28%;
  }

  .sidebar {
    width: 100%;
  }

  textarea {
    height: 160px;
  }
}

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Sudoku — Fresh Single File - By Keitozy </h1>
        <div class="small">Editable cells are highlighted red • Auto-save & mobile-ready</div>
      </div>
      <div class="controls">
        <button id="backBtn">Back</button>
        <select id="difficulty"><option value="36">Easy</option><option value="30" selected>Medium</option><option value="24">Hard</option></select>
        <button id="newBtn">New</button>
        <button id="hintBtn">Hint</button>
        <button id="clearBtn">Clear</button>
        <label style="display:inline-flex;align-items:center;gap:6px"><input id="themeToggle" type="checkbox">Dark</label>
      </div>
    </header>

    <div class="board">
      <div>
        <div id="grid" class="grid" aria-label="Sudoku grid"></div>
        <div id="numpad" style="display:flex;gap:6px;margin-top:10px;flex-wrap:wrap">
          <button class="numkey" data-val="1">1</button>
          <button class="numkey" data-val="2">2</button>
          <button class="numkey" data-val="3">3</button>
          <button class="numkey" data-val="4">4</button>
          <button class="numkey" data-val="5">5</button>
          <button class="numkey" data-val="6">6</button>
          <button class="numkey" data-val="7">7</button>
          <button class="numkey" data-val="8">8</button>
          <button class="numkey" data-val="9">9</button>
          <button class="numkey" data-val="0">Erase</button>
          <button id="notesToggle" class="numkey" data-val="notes">Notes</button>
        </div>
      </div>

      <div class="sidebar">
        <div class="panel">
          <div class="toolbar">
            <button id="applyBtn">Apply (paste 81 chars with . for blanks)</button>
            <button id="importBtn">Import TXT</button>
            <button id="exportBtn">Export TXT</button>
          </div>
          <textarea id="notepad" placeholder="Paste puzzle here..."></textarea>
          <div class="status" id="status">Ready. Mistakes: <span id="mistakes">0</span> • Hints: <span id="hints">0</span>/3 <span id="hintStars">⭐⭐⭐</span></div>
          <div style="margin-top:8px">
            <label class="small"><input type="checkbox" id="uniqueCheck"> Try to generate unique-solution puzzles (slower)</label>
          </div>
          <div style="margin-top:8px">
            <label class="small">Mistake limit: <select id="mistakeLimit"><option value="0">Off</option><option value="1">1</option><option value="3" selected>3</option><option value="5">5</option></select></label>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Features implemented (requested): B, C, D, E, F, G, H (everything except auto-solver)
const gridEl = document.getElementById('grid');
const statusEl = document.getElementById('status');
const notepad = document.getElementById('notepad');
const mistakesEl = document.getElementById('mistakes');
let board = Array(81).fill(0);
let fixed = Array(81).fill(false);
let notes = Array.from({length:81},()=>new Set()); // pencil marks
let hintCount = 0; // *** added hint counter *** Array.from({length:81},()=>new Set()); // pencil marks
let showNotes = false;
let activeCell = null;
let mistakeCount = 0;
let mistakeLimit = Number(document.getElementById('mistakeLimit').value) || 0;

function updateStatus(t){ statusEl.childNodes[0] && statusEl.childNodes[0].nodeType===3 ? statusEl.childNodes[0].textContent = t : statusEl.childNodes[0]; }
function setMistake(n){ mistakeCount = n; mistakesEl.textContent = mistakeCount; if(mistakeLimit>0 && mistakeCount>=mistakeLimit){ alert('Mistake limit reached');
     }}

// create grid and inputs
function createGrid(){
  gridEl.innerHTML='';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const idx = r*9+c;
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.idx = idx;
      if((c+1)%3===0 && c!==8) cell.classList.add('thick-col');
      if((r+1)%3===0 && r!==8) cell.classList.add('thick-row');

      const inp = document.createElement('input');
      inp.type='text'; inp.maxLength=1; inp.inputMode='numeric'; inp.dataset.idx = idx;
      inp.addEventListener('input', onInput);
      inp.addEventListener('focus', ()=>{ activeCell = inp; renderNotes(); });
      inp.addEventListener('blur', ()=>{ activeCell = null; });
      inp.addEventListener('keydown', onKeyDown);

      cell.appendChild(inp);
      gridEl.appendChild(cell);
    }
  }
}

function onInput(e){
  const v = e.target.value.replace(/[^1-9]/g,'');
  e.target.value = v;
  const idx = Number(e.target.dataset.idx);
  if(fixed[idx]){ e.target.value = board[idx] || ''; return; }
  if(showNotes){ // toggle note
    if(!v){ return; }
    const n = Number(v);
    if(notes[idx].has(n)) notes[idx].delete(n); else notes[idx].add(n);
    e.target.value = board[idx]||''; renderNotes(); saveState(); return;
  }
  board[idx] = v ? Number(v) : 0;
  markIfWrong(idx);
  saveState();
}

function onKeyDown(e){
  const idx = Number(e.target.dataset.idx);
  if(e.key==='Backspace' || e.key==='Delete'){ if(!fixed[idx]){ board[idx]=0; e.target.value=''; markIfWrong(idx); saveState(); } }
  if(e.key>='1' && e.key<='9'){ /* allowed — handled by input */ }
}

function renderNotes(){
  for(let i=0;i<81;i++){
    const cell = gridEl.querySelector(`.cell[data-idx="${i}"]`);
    const inp = cell.querySelector('input');
    // remove old note grid
    const old = cell.querySelector('.note-grid'); if(old) old.remove();
    if(showNotes && !board[i]){
      const ng = document.createElement('div'); ng.className='note-grid';
      for(let n=1;n<=9;n++){ const d=document.createElement('div'); if(notes[i].has(n)) d.textContent=n; ng.appendChild(d); }
      cell.appendChild(ng);
    }
  }
}

function updateGrid(){
  for(let i=0;i<81;i++){
    const cell = gridEl.querySelector(`.cell[data-idx="${i}"]`);
    const inp = cell.querySelector('input');
    inp.value = board[i]||'';
    cell.classList.remove('editable','fixed','wrong','selected');
    if(fixed[i]){ cell.classList.add('fixed'); inp.readOnly = true; }
    else{ cell.classList.add('editable'); inp.readOnly = false; }
  }
  renderNotes();
}

function conflictsFor(idx, val){
  const conflicts = [];
  if(!val) return conflicts;
  const r = Math.floor(idx/9), c = idx%9;
  for(let i=0;i<9;i++){
    if(i!==c && board[r*9+i]===val) conflicts.push(r*9+i);
    if(i!==r && board[i*9+c]===val) conflicts.push(i*9+c);
  }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++){ const p=(br+dr)*9+(bc+dc); if(p!==idx && board[p]===val) conflicts.push(p); }
  return [...new Set(conflicts)];
}

function markIfWrong(idx){
  const val = board[idx];
  const cell = gridEl.querySelector(`.cell[data-idx="${idx}"]`);
  if(!cell) return;
  cell.classList.remove('wrong');
  const conflicts = conflictsFor(idx,val);
  if(conflicts.length){ cell.classList.add('wrong'); // vibrate if available
    if(navigator.vibrate) navigator.vibrate(80);
    setMistake(mistakeCount+1);
    if(mistakeLimit>0 && mistakeCount+1>=mistakeLimit){ gameOver(); }
    // optionally highlight conflicts briefly
    conflicts.forEach(p=>{ const c=gridEl.querySelector(`.cell[data-idx="${p}"]`); c && c.classList.add('wrong'); setTimeout(()=>c && c.classList.remove('wrong'),500); });
  } else {
    // if previously marked wrong, ensure it's cleared
    // no-op
  }
}

// Generator (full board) and removal with optional uniqueness check
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function generateFull(){
  const arr = Array(81).fill(0);
  const nums = [1,2,3,4,5,6,7,8,9];
  function fill(pos=0){
    if(pos>=81) return true;
    const order = shuffle(nums.slice());
    for(const n of order){ if(isValidOn(arr,pos,n)){ arr[pos]=n; if(fill(pos+1)) return true; arr[pos]=0; } }
    return false;
  }
  fill(0); return arr;
}

function isValidOn(b,pos,val){
  const r=Math.floor(pos/9), c=pos%9;
  for(let i=0;i<9;i++) if(b[r*9+i]===val) return false;
  for(let i=0;i<9;i++) if(b[i*9+c]===val) return false;
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++) if(b[(br+dr)*9+(bc+dc)]===val) return false;
  return true;
}


// simple solver used for uniqueness checking (backtracking, returns count up to 2)
function countSolutions(puzzle){
  let count=0; const arr = puzzle.slice();
  function dfs(){
    if(count>1) return;
    const pos = arr.findindex(x=>x===0);
    if(pos===-1){ count++; return; }
    for(let n=1;n<=9;n++){
      if(isValidOn(arr,pos,n)){
        arr[pos]=n; dfs(); arr[pos]=0; if(count>1) return;
      }
    }
  }
  dfs(); return count;
}

function makePuzzle(clues=30, unique=false){
  const full = generateFull();
  const p = full.slice();
  const indices = Array.from({length:81},(_,i)=>i); shuffle(indices);
  let kept = clues;
  // We'll try to leave 'kept' cells and blank the rest, but attempt uniqueness if requested
  for(const idx of indices){
    if(kept>0){ kept--; continue; }
    const backup = p[idx]; p[idx]=0;
    if(unique){ const sols = countSolutions(p); if(sols!==1) p[idx]=backup; }
  }
  return p;
}

// persistence (localStorage)
function saveState(){
  const state = {board, fixed:fixed.map(f=>f?1:0), notes:notes.map(s=>Array.from(s)), mistakeCount};
  localStorage.setItem('sudoku_v1', JSON.stringify(state));
}
function loadState(){
  try{ const s=localStorage.getItem('sudoku_v1'); if(!s) return false; const o=JSON.parse(s); board=o.board||board; fixed=(o.fixed||[]).map(x=>!!x); notes=(o.notes||[]).map(arr=>new Set(arr||[])); mistakeCount=o.mistakeCount||0; mistakesEl.textContent=mistakeCount; updateGrid(); return true;}catch(e){return false}
}

// UI handlers
createGrid(); if(!loadState()) updateStatus('Ready.'); else updateStatus('Restored saved game.'); updateGrid();

document.getElementById('newBtn').addEventListener('click', ()=>{
  updateStatus('Generating...');
  const clues = Number(document.getElementById('difficulty').value)||30;
  const unique = document.getElementById('uniqueCheck').checked;
  setTimeout(()=>{
    board = makePuzzle(clues, unique);
    hintCount = 0; document.getElementById('hints').textContent = hintCount;
    updateHintStars(); // reset hints on new puzzle
    fixed = board.map(x=>x?true:false);
    notes = Array.from({length:81},()=>new Set());
    setMistake(0);
    updateGrid(); saveState(); updateStatus('New puzzle generated.');
  },50);
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  board = Array(81).fill(0); fixed = Array(81).fill(false); notes = Array.from({length:81},()=>new Set()); setMistake(0); updateGrid(); saveState(); updateStatus('Cleared.');
});

// numpad
document.getElementById('numpad').addEventListener('click', e=>{
  if(!e.target.classList.contains('numkey')) return;
  const val = e.target.dataset.val;
  if(val==='notes'){
    showNotes = !showNotes; renderNotes(); updateStatus(showNotes? 'Notes ON':'Notes OFF'); return;
  }
  if(!activeCell) return; const idx = Number(activeCell.dataset.idx); if(fixed[idx]) return;
  if(val==='0'){ board[idx]=0; activeCell.value=''; } else { board[idx]=Number(val); activeCell.value=val; }
  markIfWrong(idx); saveState();
});

// notes toggle button kept above; also keyboard N to toggle
document.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='n'){ showNotes=!showNotes; renderNotes(); updateStatus(showNotes? 'Notes ON':'Notes OFF'); } });

// Hint system
function giveHint(){
  if(hintCount >= 3){ updateStatus('No hints left (3/3).'); return; }
  const solved = board.slice(); solveBoard(solved);
  const empties = board.map((v,i)=>v===0?i:null).filter(v=>v!==null);
  if(empties.length===0) return updateStatus('No empty cells.');
  const idx = empties[Math.floor(Math.random()*empties.length)];
  board[idx] = solved[idx];
  const inp = gridEl.querySelector(`.cell[data-idx="${idx}"] input`);
  inp.value = solved[idx]; inp.parentElement.style.color='var(--good)';
  hintCount++; document.getElementById('hints').textContent = hintCount;
  updateHintStars(); updateStatus(`Hint used (${hintCount}/3).`);
  saveState();
}


function updateHintStars(){
  const stars = ['☆','⭐','⭐⭐','⭐⭐⭐'];
  const colors = ['#555','#38bdf8','#fbbf24','#22c55e'];
  document.getElementById('hintStars').textContent = stars[3-hintCount];
  document.getElementById('hintStars').style.color = colors[hintCount];
  const hb = document.getElementById('hintBtn');
  if(hintCount>=3){ hb.disabled=true; hb.style.opacity='0.4'; hb.style.cursor='not-allowed'; }
  else { hb.disabled=false; hb.style.opacity='1'; hb.style.cursor='pointer'; }
}

updateHintStars();

document.getElementById('hintBtn').addEventListener('click', giveHint);

// import/export
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const txt = board.map(x=>x?x:'.').join(''); const blob = new Blob([txt],{type:'text/plain'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sudoku.txt'; a.click(); URL.revokeObjectURL(a.href); updateStatus('Exported.');
});

document.getElementById('importBtn').addEventListener('click', ()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='text/plain'; inp.addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ notepad.value=r.result; }; r.readAsText(f); }); inp.click(); });

document.getElementById('applyBtn').addEventListener('click', ()=>{
  const txt = notepad.value.replace(/\s/g,''); if(txt.length!==81){ updateStatus('Paste exactly 81 chars (use . for blanks).'); return; }
  board = txt.split('').map(ch=> ch==='.'?0:parseInt(ch)||0); fixed = board.map(x=>!!x); notes = Array.from({length:81},()=>new Set()); setMistake(0); updateGrid(); saveState(); updateStatus('Applied.');
});

// theme toggle
const themeToggle = document.getElementById('themeToggle');
themeToggle.addEventListener('change', ()=>{
  if(themeToggle.checked){ document.documentElement.style.setProperty('--card','#0b1626'); document.documentElement.style.setProperty('--cell','#081022'); } else { document.documentElement.style.setProperty('--card','#071328'); document.documentElement.style.setProperty('--cell','#0f1724'); }
});

// helper to update grid view
function updateGrid(){
  for(let i=0;i<81;i++){
    const cell = gridEl.querySelector(`.cell[data-idx="${i}"]`);
    const inp = cell.querySelector('input');
    inp.value = board[i]||'';
    cell.classList.remove('editable','fixed','wrong');
    if(fixed[i]){ cell.classList.add('fixed'); inp.readOnly=true; } else { cell.classList.add('editable'); inp.readOnly=false; }
  }
  renderNotes();
}

function renderNotes(){
  for(let i=0;i<81;i++){
    const cell = gridEl.querySelector(`.cell[data-idx="${i}"]`);
    const old = cell.querySelector('.note-grid'); if(old) old.remove();
    if(showNotes && !board[i]){
      const ng = document.createElement('div'); ng.className='note-grid';
      for(let n=1;n<=9;n++){ const d = document.createElement('div'); if(notes[i].has(n)) d.textContent = n; ng.appendChild(d); }
      cell.appendChild(ng);
    }
  }
}

function conflictsFor(idx,val){
  const out=[]; if(!val) return out; const r=Math.floor(idx/9), c=idx%9;
  for(let i=0;i<9;i++){ if(i!==c && board[r*9+i]===val) out.push(r*9+i); if(i!==r && board[i*9+c]===val) out.push(i*9+c); }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++){ const p=(br+dr)*9+(bc+dc); if(p!==idx && board[p]===val) out.push(p); }
  return [...new Set(out)];
}

  function gameOver(){
  gridEl.style.animation='flashRed 0.4s ease-in-out 3';
  setTimeout(()=> gridEl.style.animation='',1500);

  for(let i=0;i<81;i++){
    const inp=gridEl.querySelector(`.cell[data-idx="${i}"] input`);
    inp.readOnly=true;
  }

  const solved=board.slice(); 
  solveBoard(solved);

  for(let i=0;i<81;i++){
    if(board[i]!==solved[i]){
      const inp=gridEl.querySelector(`.cell[data-idx="${i}"] input`);
      inp.value=solved[i];
      inp.parentElement.style.color='#10b981';
    }
  }

  document.getElementById('gameOverModal').style.display = 'flex';

  // ⭐ ADD AUTO-CLEAR BELOW
  setTimeout(()=> {
      board = Array(81).fill(0);
      fixed = Array(81).fill(false);
      notes = Array.from({length:81},()=>new Set());
      mistakeCount = 0;
      hintCount = 0;
      document.getElementById('hints').textContent = hintCount;
      updateHintStars();
      updateGrid();
      saveState();
      updateStatus("Board auto-cleared after Game Over.");
  }, 1200);
}

//BACK-UP EMERGENCY HAKDOG HAHAHA
//function gameOver(){
  
  //gridEl.style.animation='flashRed 0.4s ease-in-out 3';
  //setTimeout(()=> gridEl.style.animation='',1500);
  //for(let i=0;i<81;i++){ const inp=gridEl.querySelector(`.cell[data-idx="${i}"] input`); inp.readOnly=true; }
  //const solved=board.slice(); solveBoard(solved);
  //for(let i=0;i<81;i++){ if(board[i]!==solved[i]){ const inp=gridEl.querySelector(`.cell[data-idx="${i}"] input`); inp.value=solved[i]; inp.parentElement.style.color='#10b981'; }}
  //document.getElementById('gameOverModal').style.display = 'flex';
}

// quick backtracking solver
function solveBoard(b){
  function s(pos){
    if(pos>=81) return true;
    if(b[pos]!==0) return s(pos+1);
    for(let n=1;n<=9;n++){
      if(isValidOn(b,pos,n)){
        b[pos]=n;
        if(s(pos+1)) return true;
        b[pos]=0;
      }
    }
    return false;
  }
  s(0);
}

// restart handler
document.addEventListener('DOMContentLoaded',()=>{
  const r=document.getElementById('restartBtn');
  if(r){ r.onclick=()=>{ location.reload(); }; }
});

/* flash animation */
const style=document.createElement('style');
style.textContent=`@keyframes flashRed{0%{filter:none;}50%{filter:brightness(3) hue-rotate(-30deg);}100%{filter:none;}}`;
document.head.appendChild(style);

// back button handler
document.getElementById('backBtn').addEventListener('click',()=>{
  window.location.href = 'index.html'; // change if you have a different menu page
//window.location.href = '../index.html';

});

// expose some functions for debugging in console
window._sudoku = {board,fixed,notes,saveState,loadState,updateGrid};

</script>

<!-- Game Over Modal -->
<div id="gameOverModal" style="position:fixed;inset:0;background:rgba(0,0,0,0.65);display:none;align-items:center;justify-content:center;z-index:9999">
  <div style="background:#1a1a2e;padding:20px 26px;border-radius:10px;text-align:center;max-width:320px;width:90%;box-shadow:0 0 20px #ff4444">
    <h2 style="margin:0 0 10px;font-size:20px;color:#ff7777">GAME OVER</h2>
    <p style="margin:0 0 16px;color:#ddd">You reached the mistake limit.</p>
    <button id="restartBtn" style="padding:8px 14px;border-radius:6px;border:1px solid #ff4444;background:#ff4444;color:#fff;cursor:pointer">Restart</button>
  </div>
</div>
</body>
</html>
